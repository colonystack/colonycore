- [x] Harden entity-model validation rules
  - Enforce semver versioning, metadata status, duplicate checks, state machine initial/terminal values, `id_semantics`, allowed invariants, enum reachability, and property enum references in `internal/tools/entitymodel/validate`; aligned schema state definitions to pass.
- [x] Lift persistence coverage for lineage entities (Line/Strain/GenotypeMarker) in memory + SQLite stores, covering guards, migrations, and deep-copy helpers (>90% package coverage).
- [x] Finish extension payload normalization across facades and persistence
  - [x] Encode observation extensions as hook-scoped containers in JSON and prove memory snapshot round-trips preserve plugin payloads with tests.
  - [x] Rewrite plugin/dataset facades and adapter flows to pass hook-scoped payloads via typed helpers (`ExtensionSet`, etc.) instead of raw maps (e.g., dataset exporters/handlers still exchange `map[string]any` payloads).
  - [x] Update memory/SQLite stores and fixtures to serialize typed containers end-to-end, then rerun `make lint` and `make test`; document the container-only contract in ADR-0003/annex once stabilized.
    - [x] Memory store snapshots and export/import paths preserve hook-scoped extension containers for facility, breeding, sample, and supply entities.
    - [x] Memory store normalizes organism and breeding extension containers during import/create/update (SQLite parity and fixtures still pending).
- [ ] Ensure rule invariants have the data they need
  - Entity model now encodes housing, protocol, lineage, and lifecycle invariants with validator allowlists; canonical fixtures now exercise them end-to-end for memory/SQLite/Postgres.
  - [x] Normalize embedded entitymodel literals across domain/plugin tests to avoid drift between manual fixtures and generated structs; revisit if schema introduces new fields.
  - [ ] Complete Entity Model v0 canon
    - [x] Anchor plugin contract outline at `docs/annex/plugin-contract.md` and fixtures path at `testutil/fixtures/entity-model/`.
    - [x] Align schema enums/states with RFC-0001 compliance + housing lifecycles (code/plugins to follow).
    - [x] Bring domain/constants and contexts up to the RFC-aligned schema (protocol/permit/housing states): pluginapi/datasetapi contexts now source state/status constants from the generated entity model, dataset facades consume them, and lint regenerates API snapshots alongside entity-model artifacts.
      - [x] Persistence adapters normalise housing/protocol/permit states and environments to generated enums (memory + sqlite).
      - [x] Persistence adapters normalise procedure/treatment/sample statuses to generated enums; dataset facades now normalize lifecycle/status/environment fields to the generated constants with coverage.
    - [x] Replace handwritten structs in `pkg/domain/entities.go` with wrappers or embeddings of `pkg/domain/entitymodel` outputs so schema-driven fields can’t drift; confirm extension containers and persistence adapters continue to operate with the generated shapes (guarded by embedding tests).
    - [x] Fill `entity-model.json` gaps: natural keys, invariants, relationships, and enums for every RFC-0001 entity (Line/Strain/GenotypeMarker included) — relationships/invariants are now explicit (including lineage/protocol/lifecycle constraints), natural keys scoped, and enums/natural-key scopes reviewed against RFC-0001 before freeze.
    - [x] Stand up generators driven solely from the JSON plus `make entity-model-generate` wiring (Go/OpenAPI/SQL/ERD targets hooked into `make entity-model-verify`; SVGs rendered via Graphviz).
      - [x] Go types/enums emitted to `pkg/domain/entitymodel`.
    - [x] OpenAPI components.
    - [x] Postgres/SQLite DDL with FK-aware ordering, join tables for array relationships, derived arrays omitted, and FK indexes.
    - [x] ERD export (DOT + SVG) with Graphviz rendering and SVG fallback for headless runs; SchemaSpy target now loads generated DDL with `ON_ERROR_STOP` and emits `docs/annex/entity-model-erd.svg` from a temp Postgres container.
    - [x] Generate the plugin contract content from `entity-model.json` (replacing the outline) and update `scripts/validate_plugin_patterns.go` to enforce mandatory fields/extension hooks directly from the contract (metadata block now emitted + validated during lint).
    - [x] Extend `scripts/validate_plugin_patterns.go` (or a sibling tool) to cross-check plugin code against the contract metadata so create/update flows set required fields and only touch sanctioned extension hooks; fail `make lint` when plugins drift.
    - [x] Emit canonical fixtures from the schema under `testutil/fixtures/entity-model`, then load them into SQLite/Postgres adapters during CI to hit ≥95% invariant coverage and prove storage parity.
    - [x] Wire the generated Postgres/SQLite DDL into their adapters/migration flows and add a round-trip smoke test (apply migrations, run `entity-model-diff`, verify ERD) so code can’t diverge from stored schemas.
      - [x] SQLite snapshots execute the embedded schema DDL on startup, `entity-model-diff` now enforces the fingerprint during lint, and the generator round-trip test loads the DDL into SQLite and asserts the ERD contains every table.
        - [x] Runtime adapters now import the canonical docs-based DDL bundle (`docs/schema/sql/bundle.go` → `internal/entitymodel/sqlbundle`) instead of copied files, keeping schema consumers on the single generated source of truth.
      - [x] Introduce a Postgres persistence adapter that applies the generated DDL at runtime and runs the same store conformance tests as SQLite so both backends satisfy the acceptance criteria.
    - [x] Map every schema-declared invariant (housing capacity, protocol subject cap, lineage integrity, lifecycle transition, protocol coverage) to a concrete rule handler in `internal/core` and fail validation when a schema entry lacks an implementation.
      - `internal/core/rule_lineage_integrity.go`, `rule_lifecycle_transition.go`, and `rule_protocol_coverage.go` now cover the remaining invariants and are registered via `NewDefaultRulesEngine`.
    - [x] Ensure OpenAPI handlers/clients consume `docs/schema/openapi/entity-model.yaml`; add a CI guard that regenerates and diffs the components so stale DTOs fail `make lint`.
      - Embedded OpenAPI helper exposes the canonical spec via `internal/entitymodel.OpenAPISpec`/`NewOpenAPIHandler`, and generator tests now diff the committed YAML against the schema output to block drift.
- [x] Wire entity-model tooling into workflows
  - [x] Make `make entity-model-validate` runnable and execute it from `make lint` so schema drift fails fast.
  - [x] Extend `entity-model-generate`/`entity-model-verify` placeholders into real generators plus a pre-commit hook so CI and contributors run the same checks and outputs (Go/OpenAPI/SQL/ERD now generated; pre-commit hook runs `make lint` → `entity-model-verify`).
- [x] Add relational projection layer for entity-model
  - [x] Introduce per-relationship `storage` hints (`fk`/`join`/`derived`/`json`) defaulted by rules; validator now rejects unknown storage values.
  - [x] Compile arrays without inverse FKs into join tables with deterministic names/constraints/indexes; treat inverse-array + scalar-FK pairs as derived to avoid duplicated storage; drop JSONB `*_ids` columns when join tables are emitted.
  - [x] Keep logical JSON schema unchanged for API shape; emit relational DDL (PG/SQLite) from the compiled projection; add golden tests plus smoke `psql` load to ensure SchemaSpy sees real FKs.
- [x] Enforce entity-model integrity in generated DDL/ERD (next slice)
  - [x] Deduplicate many-to-many tables so each relationship emits a single join table (`facilities__project_ids` vs `projects__facility_ids`, `projects__supply_item_ids` vs `supply_items__project_ids`); update ERD output after the generator change.
  - [x] Emit DB-level constraints for schema guarantees: unique indexes for natural keys (Facility.code, Project.code, Sample facility_id+identifier, Permit authority+permit_number, etc.) and CHECK/ENUM constraints for lifecycle/status/environment enums instead of plain TEXT columns.
  - [x] Add enforcement for required relationship arrays (e.g., permit facility_ids/protocol_ids, line/strain genotype markers, supply item/project facility bindings) so “at least one link” is validated at the storage layer.
- [x] Patch entity-model DDL/ERD projection gaps from the latest integrity review
  - Fix join-table de-duplication so distinct array relationships to the same target both persist (schema defines `BreedingUnit.female_ids` and `BreedingUnit.male_ids`, and the generated DDL/ERD now includes both join tables).
  - Add required-join enforcement for schema-required arrays that currently lacked it (permits `protocol_ids`; supply items `project_ids`) so the DDL matches `docs/schema/entity-model.json`.
- [x] Move the Postgres store off the JSON snapshot into the generated normalized tables (apply DDL on startup, load/persist via entity-model fixtures, and validate with stubbed normalized tests for >90% coverage).
- [ ] Address schema feedback from latest review
  - [x] Decide how to surface `Facility.housing_unit_ids`: marked explicitly derived in the contract so DDL stays normalized to `housing_units.facility_id`.
  - [x] Tighten cardinality parity by adding `minItems` where relationships are `1..n` (Line genotype markers, Permit facility/protocol links, Project facilities, Supply item facilities/projects, Sample chain-of-custody, Permit allowed_activities) so JSON Schema, DDL triggers, and OpenAPI all enforce non-empty links.
  - [x] Bring SQLite/memory enforcement closer to Postgres: Postgres uses constraint triggers for required relationship arrays, but SQLite/memory only enforce existence. Either document divergence or add parity checks. (Memory + SQLite stores now reject empty required arrays via store-level validation plus guard tests.)
  - [x] Confirm cardinality encoding expectation with reviewer: the model validates `0..1/1..1/0..n/1..n`; no single-dot forms are present, so ensure downstream tooling matches this notation (documented and locked by validator tests).
