package main

import (
	"encoding/json"
	"fmt"
	"sort"
	"strings"
)

type dialectSpec struct {
	name         string
	stringType   string
	integerType  string
	numberType   string
	booleanType  string
	dateTimeType string
	uuidType     string
	jsonType     string
}

var (
	postgresDialect = dialectSpec{
		name:         "postgres",
		stringType:   "TEXT",
		integerType:  "INTEGER",
		numberType:   "DOUBLE PRECISION",
		booleanType:  "BOOLEAN",
		dateTimeType: "TIMESTAMPTZ",
		uuidType:     "UUID",
		jsonType:     "JSONB",
	}
	sqliteDialect = dialectSpec{
		name:         "sqlite",
		stringType:   "TEXT",
		integerType:  "INTEGER",
		numberType:   "REAL",
		booleanType:  "INTEGER",
		dateTimeType: "TEXT",
		uuidType:     "TEXT",
		jsonType:     "JSON",
	}
)

const (
	storageFK      = "fk"
	storageJoin    = "join"
	storageDerived = "derived"
	storageJSON    = "json"
)

type columnSpec struct {
	name       string
	typ        string
	notNull    bool
	enumValues []string
}

type relationshipDecision struct {
	storage  string
	isArray  bool
	explicit bool
	target   string
}

type tableSpec struct {
	name          string
	columns       []columnSpec
	primaryKey    []string
	fks           []string
	checks        []string
	indexes       []string
	deps          []string
	entityColumns map[string]string
}

type requiredJoin struct {
	parentTable string
	joinTable   string
	parentCol   string
}

type joinRecord struct {
	joinName string
	source   string
}

func generateSQL(doc schemaDoc) ([]byte, []byte, error) {
	pg, err := buildSQLForDialect(doc, postgresDialect)
	if err != nil {
		return nil, nil, err
	}

	sqlite, err := buildSQLForDialect(doc, sqliteDialect)
	if err != nil {
		return nil, nil, err
	}

	return []byte(pg), []byte(sqlite), nil
}

func buildSQLForDialect(doc schemaDoc, dialect dialectSpec) (string, error) {
	tables, requiredJoins, err := compileTables(doc, dialect)
	if err != nil {
		return "", err
	}

	order, err := topologicallySortedTables(tables)
	if err != nil {
		return "", err
	}

	var b strings.Builder
	fmt.Fprintf(&b, "-- Code generated by internal/tools/entitymodel/generate. DO NOT EDIT.\n")
	fmt.Fprintf(&b, "-- Dialect: %s\n\n", dialect.name)

	for i, name := range order {
		table := tables[name]
		fmt.Fprintf(&b, "CREATE TABLE IF NOT EXISTS %s (\n", table.name)
		for idx, col := range table.columns {
			fmt.Fprintf(&b, "    %s %s", col.name, col.typ)
			if col.notNull {
				b.WriteString(" NOT NULL")
			}
			if idx < len(table.columns)-1 || len(table.fks)+len(table.checks)+len(table.primaryKey) > 0 {
				b.WriteString(",")
			}
			b.WriteString("\n")
		}
		var constraints []string
		if len(table.primaryKey) > 0 {
			constraints = append(constraints, fmt.Sprintf("PRIMARY KEY (%s)", strings.Join(table.primaryKey, ", ")))
		}
		constraints = append(constraints, table.fks...)
		constraints = append(constraints, table.checks...)
		for j, c := range constraints {
			fmt.Fprintf(&b, "    %s", c)
			if j < len(constraints)-1 {
				b.WriteString(",")
			}
			b.WriteString("\n")
		}

		b.WriteString(");\n")

		for _, idx := range table.indexes {
			fmt.Fprintf(&b, "%s;\n", idx)
		}

		if i < len(order)-1 {
			b.WriteString("\n")
		}
	}

	if len(requiredJoins) > 0 && dialect.name == postgresDialect.name {
		b.WriteString("\n")
		b.WriteString("CREATE OR REPLACE FUNCTION enforce_required_join_parent() RETURNS trigger AS $$\n")
		b.WriteString("DECLARE\n")
		b.WriteString("    has_link boolean;\n")
		b.WriteString("    join_table text := TG_ARGV[0];\n")
		b.WriteString("    join_column text := TG_ARGV[1];\n")
		b.WriteString("    sql text;\n")
		b.WriteString("BEGIN\n")
		b.WriteString("    sql := format('SELECT EXISTS (SELECT 1 FROM %I WHERE %I = $1)', join_table, join_column);\n")
		b.WriteString("    EXECUTE sql INTO has_link USING NEW.id;\n")
		b.WriteString("    IF NOT has_link THEN\n")
		b.WriteString("        RAISE EXCEPTION 'missing required relationship on % for %', join_table, NEW.id;\n")
		b.WriteString("    END IF;\n")
		b.WriteString("    RETURN NEW;\n")
		b.WriteString("END;\n")
		b.WriteString("$$ LANGUAGE plpgsql;\n\n")

		b.WriteString("CREATE OR REPLACE FUNCTION enforce_required_join_link() RETURNS trigger AS $$\n")
		b.WriteString("DECLARE\n")
		b.WriteString("    join_table text := TG_ARGV[0];\n")
		b.WriteString("    join_column text := TG_ARGV[1];\n")
		b.WriteString("    parent_table text := TG_ARGV[2];\n")
		b.WriteString("    parent_id uuid;\n")
		b.WriteString("    has_parent boolean;\n")
		b.WriteString("    has_link boolean;\n")
		b.WriteString("    sql text;\n")
		b.WriteString("    row_record record;\n")
		b.WriteString("BEGIN\n")
		b.WriteString("    row_record := COALESCE(NEW, OLD);\n")
		b.WriteString("    sql := format('SELECT ($1).%I', join_column);\n")
		b.WriteString("    EXECUTE sql INTO parent_id USING row_record;\n")
		b.WriteString("    IF parent_id IS NULL THEN\n")
		b.WriteString("        RETURN COALESCE(NEW, OLD);\n")
		b.WriteString("    END IF;\n")
		b.WriteString("    sql := format('SELECT EXISTS (SELECT 1 FROM %I WHERE id = $1)', parent_table);\n")
		b.WriteString("    EXECUTE sql INTO has_parent USING parent_id;\n")
		b.WriteString("    IF NOT has_parent THEN\n")
		b.WriteString("        RETURN COALESCE(NEW, OLD);\n")
		b.WriteString("    END IF;\n")
		b.WriteString("    sql := format('SELECT EXISTS (SELECT 1 FROM %I WHERE %I = $1)', join_table, join_column);\n")
		b.WriteString("    EXECUTE sql INTO has_link USING parent_id;\n")
		b.WriteString("    IF NOT has_link THEN\n")
		b.WriteString("        RAISE EXCEPTION 'missing required relationship on % for %', parent_table, parent_id;\n")
		b.WriteString("    END IF;\n")
		b.WriteString("    RETURN COALESCE(NEW, OLD);\n")
		b.WriteString("END;\n")
		b.WriteString("$$ LANGUAGE plpgsql;\n\n")

		seenTriggers := make(map[string]struct{})
		for _, req := range requiredJoins {
			parentTrigger := fmt.Sprintf("%s_%s_%s_required", strings.ReplaceAll(req.parentTable, ".", "_"), strings.ReplaceAll(req.joinTable, ".", "_"), req.parentCol)
			joinTrigger := fmt.Sprintf("%s_%s_guard", strings.ReplaceAll(req.joinTable, ".", "_"), req.parentCol)

			if _, ok := seenTriggers[parentTrigger]; !ok {
				fmt.Fprintf(&b, "CREATE CONSTRAINT TRIGGER %s AFTER INSERT OR UPDATE ON %s DEFERRABLE INITIALLY DEFERRED FOR EACH ROW EXECUTE FUNCTION enforce_required_join_parent('%s', '%s');\n", parentTrigger, req.parentTable, req.joinTable, req.parentCol)
				seenTriggers[parentTrigger] = struct{}{}
			}
			if _, ok := seenTriggers[joinTrigger]; !ok {
				fmt.Fprintf(&b, "CREATE CONSTRAINT TRIGGER %s AFTER INSERT OR UPDATE OR DELETE ON %s DEFERRABLE INITIALLY DEFERRED FOR EACH ROW EXECUTE FUNCTION enforce_required_join_link('%s', '%s', '%s');\n", joinTrigger, req.joinTable, req.joinTable, req.parentCol, req.parentTable)
				seenTriggers[joinTrigger] = struct{}{}
			}
		}
	}

	return b.String(), nil
}

func compileTables(doc schemaDoc, dialect dialectSpec) (map[string]tableSpec, []requiredJoin, error) {
	decisions, err := resolveRelationshipStorage(doc.Entities, doc.Enums, doc.Definitions)
	if err != nil {
		return nil, nil, err
	}

	tables := make(map[string]tableSpec, len(doc.Entities)*2)
	entityNames := sortedKeys(doc.Entities)
	var requiredJoins []requiredJoin
	joinPairSeen := make(map[string][]joinRecord)

	for _, entName := range entityNames {
		ent := doc.Entities[entName]
		props, _ := parseProperties(ent.Properties)
		drops := make(map[string]struct{})
		ensureRequired := make(map[string]struct{})
		var fks []string
		var deps []string
		var indexes []string
		var checks []string

		for _, relName := range sortedKeys(ent.Relationships) {
			rel := ent.Relationships[relName]
			decision := decisions[entName][relName]
			prop, ok := props[relName]
			isArray := ok && isArrayProperty(prop, doc.Enums, doc.Definitions)
			targetTable := pluralize(toSnake(rel.Target))

			switch decision.storage {
			case storageDerived:
				drops[relName] = struct{}{}
			case storageJoin:
				if !isArray {
					return nil, nil, fmt.Errorf("entity %q relationship %q uses join storage but is not an array", entName, relName)
				}
				drops[relName] = struct{}{}
				join := buildJoinTable(entName, relName, rel.Target, dialect)
				pairKey := joinPairKey(entName, rel.Target, relName)
				records := joinPairSeen[pairKey]
				joinName := join.name
				reused := false
				for _, rec := range records {
					if rec.source != entName {
						joinName = rec.joinName
						reused = true
						break
					}
				}
				if !reused {
					tables[join.name] = join
					joinPairSeen[pairKey] = append(records, joinRecord{
						joinName: join.name,
						source:   entName,
					})
				}

				if contains(ent.Required, relName) {
					spec, ok := tables[joinName]
					if !ok {
						spec = join
						tables[joinName] = spec
					}
					parentCol := spec.entityColumns[toSnake(entName)]
					if parentCol == "" {
						parentCol = spec.entityColumns[entName]
					}
					if parentCol == "" {
						return nil, nil, fmt.Errorf("join table %q missing column mapping for entity %q", joinName, entName)
					}
					requiredJoins = append(requiredJoins, requiredJoin{
						parentTable: pluralize(toSnake(entName)),
						joinTable:   joinName,
						parentCol:   parentCol,
					})
				}
			case storageFK:
				if isArray {
					return nil, nil, fmt.Errorf("entity %q relationship %q uses fk storage but property is an array", entName, relName)
				}
				if strings.TrimSpace(rel.Cardinality) == "1..1" {
					ensureRequired[relName] = struct{}{}
				}
				fks = append(fks, fmt.Sprintf("FOREIGN KEY (%s) REFERENCES %s(id)", relName, targetTable))
				deps = append(deps, targetTable)
				indexes = append(indexes, fmt.Sprintf("CREATE INDEX IF NOT EXISTS idx_%s_%s ON %s (%s)", pluralize(toSnake(entName)), relName, pluralize(toSnake(entName)), relName))
			case storageJSON:
				// keep as-is
			default:
				return nil, nil, fmt.Errorf("entity %q relationship %q has unknown storage %q", entName, relName, decision.storage)
			}
		}

		sort.Strings(fks)
		sort.Strings(indexes)

		filtered := filterEntity(ent, drops, ensureRequired)
		columns, _, err := sqlColumnsForEntity(filtered, doc.Enums, doc.Definitions, dialect)
		if err != nil {
			return nil, nil, fmt.Errorf("entity %q: %w", entName, err)
		}
		if len(columns) == 0 {
			return nil, nil, fmt.Errorf("entity %q has no properties", entName)
		}
		if !hasIDColumn(columns) {
			return nil, nil, fmt.Errorf("entity %q missing id column", entName)
		}

		checks = append(checks, enumChecks(columns)...)

		for idx, nk := range ent.NaturalKeys {
			if len(nk.Fields) == 0 {
				return nil, nil, fmt.Errorf("entity %q natural key %d has no fields", entName, idx)
			}
			for _, field := range nk.Fields {
				if _, ok := filtered.Properties[field]; !ok {
					return nil, nil, fmt.Errorf("entity %q natural key %d references missing field %q", entName, idx, field)
				}
			}
			indexes = append(indexes, fmt.Sprintf("CREATE UNIQUE INDEX IF NOT EXISTS idx_%s_nk_%d ON %s (%s)", pluralize(toSnake(entName)), idx+1, pluralize(toSnake(entName)), strings.Join(nk.Fields, ", ")))
		}

		tableName := pluralize(toSnake(entName))
		tables[tableName] = tableSpec{
			name:       tableName,
			columns:    columns,
			primaryKey: []string{"id"},
			fks:        fks,
			checks:     checks,
			indexes:    indexes,
			deps:       uniqueStrings(deps),
		}
	}

	return tables, requiredJoins, nil
}

func joinPairKey(sourceEntity, targetEntity, relName string) string {
	source := toSnake(sourceEntity)
	target := toSnake(targetEntity)
	if source == target {
		return fmt.Sprintf("%s|%s", source, toSnake(relName))
	}
	if source < target {
		return fmt.Sprintf("%s|%s", source, target)
	}
	return fmt.Sprintf("%s|%s", target, source)
}

func filterEntity(ent entitySpec, drop map[string]struct{}, ensureRequired map[string]struct{}) entitySpec {
	props := make(map[string]json.RawMessage, len(ent.Properties))
	for name, prop := range ent.Properties {
		if _, skip := drop[name]; skip {
			continue
		}
		props[name] = prop
	}

	var required []string
	for _, name := range ent.Required {
		if _, ok := props[name]; ok {
			required = append(required, name)
		}
	}
	extraRequired := sortedKeys(ensureRequired)
	for _, name := range extraRequired {
		if _, ok := props[name]; ok && !contains(required, name) {
			required = append(required, name)
		}
	}
	sort.Strings(required)

	ent.Properties = props
	ent.Required = required
	return ent
}

func buildJoinTable(sourceEntity, relName, targetEntity string, dialect dialectSpec) tableSpec {
	sourceTable := pluralize(toSnake(sourceEntity))
	targetTable := pluralize(toSnake(targetEntity))
	sourceCol := fmt.Sprintf("%s_id", toSnake(sourceEntity))
	targetColBase := toSnake(targetEntity)
	if targetColBase == toSnake(sourceEntity) {
		targetColBase = toSnake(relName)
	}
	targetCol := fmt.Sprintf("%s_id", targetColBase)

	entityCols := map[string]string{
		toSnake(sourceEntity): sourceCol,
	}
	if _, ok := entityCols[toSnake(targetEntity)]; !ok {
		entityCols[toSnake(targetEntity)] = targetCol
	}

	fks := []string{
		fmt.Sprintf("FOREIGN KEY (%s) REFERENCES %s(id) ON DELETE CASCADE", sourceCol, sourceTable),
		fmt.Sprintf("FOREIGN KEY (%s) REFERENCES %s(id) ON DELETE RESTRICT", targetCol, targetTable),
	}

	return tableSpec{
		name:       fmt.Sprintf("%s__%s", sourceTable, toSnake(relName)),
		columns:    []columnSpec{{name: sourceCol, typ: dialect.uuidType, notNull: true}, {name: targetCol, typ: dialect.uuidType, notNull: true}},
		primaryKey: []string{sourceCol, targetCol},
		fks:        fks,
		indexes: []string{
			fmt.Sprintf("CREATE INDEX IF NOT EXISTS idx_%s_%s ON %s (%s)", fmt.Sprintf("%s__%s", sourceTable, toSnake(relName)), targetCol, fmt.Sprintf("%s__%s", sourceTable, toSnake(relName)), targetCol),
		},
		deps:          []string{sourceTable, targetTable},
		entityColumns: entityCols,
	}
}

func sqlColumnsForEntity(ent entitySpec, enums map[string]enumSpec, defs map[string]definitionSpec, dialect dialectSpec) ([]columnSpec, map[string]definitionSpec, error) {
	parsed, _ := parseProperties(ent.Properties)
	names := sortedKeys(parsed)
	cols := make([]columnSpec, 0, len(parsed))

	for _, name := range names {
		prop := parsed[name]
		sqlType, err := sqlTypeForProperty(prop, enums, defs, dialect)
		if err != nil {
			return nil, nil, fmt.Errorf("property %q: %w", name, err)
		}
		enumVals := enumValuesForProperty(prop, enums)
		cols = append(cols, columnSpec{
			name:       name,
			typ:        sqlType,
			notNull:    contains(ent.Required, name),
			enumValues: enumVals,
		})
	}

	return cols, parsed, nil
}

func enumValuesForProperty(prop definitionSpec, enums map[string]enumSpec) []string {
	if strings.HasPrefix(prop.Ref, "#/enums/") {
		key := strings.TrimPrefix(prop.Ref, "#/enums/")
		if enum, ok := enums[key]; ok {
			return enum.Values
		}
	}
	return nil
}

func isArrayProperty(prop definitionSpec, enums map[string]enumSpec, defs map[string]definitionSpec) bool {
	resolved, err := resolveProperty(prop, enums, defs)
	if err != nil {
		return false
	}
	return resolved.Type == typeArray
}

func resolveRelationshipStorage(entities map[string]entitySpec, enums map[string]enumSpec, defs map[string]definitionSpec) (map[string]map[string]relationshipDecision, error) {
	decisions := make(map[string]map[string]relationshipDecision, len(entities))

	for _, entName := range sortedKeys(entities) {
		ent := entities[entName]
		props, _ := parseProperties(ent.Properties)
		relDecisions := make(map[string]relationshipDecision, len(ent.Relationships))
		for _, relName := range sortedKeys(ent.Relationships) {
			rel := ent.Relationships[relName]
			prop := props[relName]
			isArray := isArrayProperty(prop, enums, defs)
			storage := strings.TrimSpace(rel.Storage)
			explicit := storage != ""
			if storage == "" {
				if isArray {
					storage = storageJoin
				} else {
					storage = storageFK
				}
			}

			if storage == storageFK && isArray {
				return nil, fmt.Errorf("entity %q relationship %q uses fk storage but property is an array", entName, relName)
			}
			if storage == storageJoin && !isArray {
				return nil, fmt.Errorf("entity %q relationship %q uses join storage but property is not an array", entName, relName)
			}
			relDecisions[relName] = relationshipDecision{
				storage:  storage,
				isArray:  isArray,
				explicit: explicit,
				target:   rel.Target,
			}
		}
		decisions[entName] = relDecisions
	}

	for _, entName := range sortedKeys(decisions) {
		relDecisions := decisions[entName]
		for _, relName := range sortedKeys(relDecisions) {
			decision := relDecisions[relName]
			if decision.storage != storageJoin || decision.explicit || !decision.isArray {
				continue
			}
			targetDecisions, ok := decisions[decision.target]
			if !ok {
				continue
			}
			for _, tDecision := range targetDecisions {
				if tDecision.target == entName && tDecision.storage == storageFK && !tDecision.isArray {
					decision.storage = storageDerived
					relDecisions[relName] = decision
					break
				}
			}
		}
	}

	return decisions, nil
}

func enumChecks(cols []columnSpec) []string {
	var checks []string
	for _, col := range cols {
		if len(col.enumValues) == 0 {
			continue
		}
		var quoted []string
		for _, v := range col.enumValues {
			quoted = append(quoted, fmt.Sprintf("'%s'", strings.ReplaceAll(v, "'", "''")))
		}
		expr := fmt.Sprintf("%s IN (%s)", col.name, strings.Join(quoted, ", "))
		if !col.notNull {
			expr = fmt.Sprintf("(%s OR %s IS NULL)", expr, col.name)
		}
		checks = append(checks, fmt.Sprintf("CHECK (%s)", expr))
	}
	return checks
}

func topologicallySortedTables(tables map[string]tableSpec) ([]string, error) {
	adj := make(map[string][]string, len(tables))
	inDegree := make(map[string]int, len(tables))

	for name, table := range tables {
		if _, ok := inDegree[name]; !ok {
			inDegree[name] = 0
		}
		deps := uniqueStrings(table.deps)
		for _, dep := range deps {
			adj[dep] = append(adj[dep], name)
			inDegree[name]++
		}
	}

	for name := range adj {
		sort.Strings(adj[name])
	}

	var queue []string
	for name, deg := range inDegree {
		if deg == 0 {
			queue = append(queue, name)
		}
	}
	sort.Strings(queue)

	var ordered []string
	for len(queue) > 0 {
		current := queue[0]
		queue = queue[1:]
		ordered = append(ordered, current)
		for _, dep := range adj[current] {
			inDegree[dep]--
			if inDegree[dep] == 0 {
				queue = append(queue, dep)
				sort.Strings(queue)
			}
		}
	}

	if len(ordered) != len(tables) {
		return nil, fmt.Errorf("cycle detected in table dependencies; cannot order %d tables", len(tables))
	}
	return ordered, nil
}

func uniqueStrings(values []string) []string {
	if len(values) == 0 {
		return nil
	}
	sort.Strings(values)
	out := []string{values[0]}
	for i := 1; i < len(values); i++ {
		if values[i] != values[i-1] {
			out = append(out, values[i])
		}
	}
	return out
}

func sqlTypeForProperty(prop definitionSpec, enums map[string]enumSpec, defs map[string]definitionSpec, dialect dialectSpec) (string, error) {
	resolved, err := resolveProperty(prop, enums, defs)
	if err != nil {
		return "", err
	}

	switch resolved.Type {
	case typeString:
		switch strings.ToLower(resolved.Format) {
		case "uuid", "uuidv7", "uuidv4":
			return dialect.uuidType, nil
		case dateTimeFormat:
			return dialect.dateTimeType, nil
		default:
			return dialect.stringType, nil
		}
	case typeInteger:
		return dialect.integerType, nil
	case typeNumber:
		return dialect.numberType, nil
	case typeBoolean:
		return dialect.booleanType, nil
	case typeArray, typeObject:
		return dialect.jsonType, nil
	default:
		if len(resolved.Properties) > 0 {
			return dialect.jsonType, nil
		}
	}

	return dialect.jsonType, nil
}

func resolveProperty(prop definitionSpec, enums map[string]enumSpec, defs map[string]definitionSpec) (definitionSpec, error) {
	if prop.Ref == "" {
		return prop, nil
	}
	if def := resolveRef(prop.Ref, enums, defs); def != nil {
		return *def, nil
	}
	return prop, fmt.Errorf("unsupported ref %q", prop.Ref)
}

func hasIDColumn(cols []columnSpec) bool {
	for _, col := range cols {
		if col.name == "id" {
			return true
		}
	}
	return false
}

func resolveRef(ref string, enums map[string]enumSpec, defs map[string]definitionSpec) *definitionSpec {
	const enumPrefix = "#/enums/"
	const defPrefix = "#/definitions/"

	switch {
	case strings.HasPrefix(ref, enumPrefix):
		if _, ok := enums[strings.TrimPrefix(ref, enumPrefix)]; ok {
			return &definitionSpec{Type: typeString}
		}
	case strings.HasPrefix(ref, defPrefix):
		if def, ok := defs[strings.TrimPrefix(ref, defPrefix)]; ok {
			return &def
		}
	}
	return nil
}

func toSnake(s string) string {
	runes := []rune(s)
	if len(runes) == 0 {
		return ""
	}

	var out []rune
	appendUnderscore := func() {
		if len(out) == 0 || out[len(out)-1] != '_' {
			out = append(out, '_')
		}
	}
	for i, r := range runes {
		if r == '-' || r == ' ' || r == '.' {
			appendUnderscore()
			continue
		}
		if isUpperASCII(r) {
			if i > 0 {
				prev := runes[i-1]
				if isLowerASCII(prev) || (i+1 < len(runes) && isLowerASCII(runes[i+1])) {
					appendUnderscore()
				}
			}
			out = append(out, toLowerASCII(r))
			continue
		}
		out = append(out, r)
	}
	return string(out)
}

func isUpperASCII(r rune) bool {
	return r >= 'A' && r <= 'Z'
}

func isLowerASCII(r rune) bool {
	return r >= 'a' && r <= 'z'
}

func toLowerASCII(r rune) rune {
	if isUpperASCII(r) {
		return r + ('a' - 'A')
	}
	return r
}

func pluralize(s string) string {
	if strings.HasSuffix(s, "s") {
		return s
	}
	if strings.HasSuffix(s, "y") && len(s) > 1 {
		prev := s[len(s)-2]
		switch prev {
		case 'a', 'e', 'i', 'o', 'u':
		default:
			return s[:len(s)-1] + "ies"
		}
	}
	return s + "s"
}
