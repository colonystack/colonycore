package main

import (
	"fmt"
	"strings"
)

type dialectSpec struct {
	name         string
	stringType   string
	integerType  string
	numberType   string
	booleanType  string
	dateTimeType string
	uuidType     string
	jsonType     string
}

var (
	postgresDialect = dialectSpec{
		name:         "postgres",
		stringType:   "TEXT",
		integerType:  "INTEGER",
		numberType:   "DOUBLE PRECISION",
		booleanType:  "BOOLEAN",
		dateTimeType: "TIMESTAMPTZ",
		uuidType:     "UUID",
		jsonType:     "JSONB",
	}
	sqliteDialect = dialectSpec{
		name:         "sqlite",
		stringType:   "TEXT",
		integerType:  "INTEGER",
		numberType:   "REAL",
		booleanType:  "INTEGER",
		dateTimeType: "TEXT",
		uuidType:     "TEXT",
		jsonType:     "JSON",
	}
)

type columnSpec struct {
	name    string
	typ     string
	notNull bool
}

func generateSQL(doc schemaDoc) ([]byte, []byte, error) {
	pg, err := buildSQLForDialect(doc, postgresDialect)
	if err != nil {
		return nil, nil, err
	}

	sqlite, err := buildSQLForDialect(doc, sqliteDialect)
	if err != nil {
		return nil, nil, err
	}

	return []byte(pg), []byte(sqlite), nil
}

func buildSQLForDialect(doc schemaDoc, dialect dialectSpec) (string, error) {
	var b strings.Builder
	fmt.Fprintf(&b, "-- Code generated by internal/tools/entitymodel/generate. DO NOT EDIT.\n")
	fmt.Fprintf(&b, "-- Dialect: %s\n\n", dialect.name)

	entityNames := sortedKeys(doc.Entities)
	for i, name := range entityNames {
		entity := doc.Entities[name]
		columns, parsedProps, err := sqlColumnsForEntity(entity, doc.Enums, doc.Definitions, dialect)
		if err != nil {
			return "", fmt.Errorf("entity %q: %w", name, err)
		}
		if len(columns) == 0 {
			return "", fmt.Errorf("entity %q has no properties", name)
		}
		if !hasIDColumn(columns) {
			return "", fmt.Errorf("entity %q missing id column", name)
		}

		tableName := pluralize(toSnake(name))
		fmt.Fprintf(&b, "CREATE TABLE IF NOT EXISTS %s (\n", tableName)
		for _, col := range columns {
			fmt.Fprintf(&b, "    %s %s", col.name, col.typ)
			if col.notNull {
				b.WriteString(" NOT NULL")
			}
			b.WriteString(",\n")
		}
		b.WriteString("    PRIMARY KEY (id)")

		fks := sqlForeignKeys(entity, parsedProps, doc.Enums, doc.Definitions)
		if len(fks) > 0 {
			b.WriteString(",\n")
			for j, fk := range fks {
				fmt.Fprintf(&b, "    %s", fk)
				if j < len(fks)-1 {
					b.WriteString(",")
				}
				b.WriteString("\n")
			}
		} else {
			b.WriteString("\n")
		}

		b.WriteString(");\n")
		if i < len(entityNames)-1 {
			b.WriteString("\n")
		}
	}

	return b.String(), nil
}

func sqlColumnsForEntity(ent entitySpec, enums map[string]enumSpec, defs map[string]definitionSpec, dialect dialectSpec) ([]columnSpec, map[string]definitionSpec, error) {
	parsed, _ := parseProperties(ent.Properties)
	names := sortedKeys(parsed)
	cols := make([]columnSpec, 0, len(parsed))

	for _, name := range names {
		prop := parsed[name]
		sqlType, err := sqlTypeForProperty(prop, enums, defs, dialect)
		if err != nil {
			return nil, nil, fmt.Errorf("property %q: %w", name, err)
		}
		cols = append(cols, columnSpec{
			name:    name,
			typ:     sqlType,
			notNull: contains(ent.Required, name),
		})
	}

	return cols, parsed, nil
}

func sqlForeignKeys(ent entitySpec, props map[string]definitionSpec, enums map[string]enumSpec, defs map[string]definitionSpec) []string {
	relations := sortedKeys(ent.Relationships)
	fks := make([]string, 0, len(relations))

	for _, name := range relations {
		prop, ok := props[name]
		if !ok {
			continue
		}
		if isArrayProperty(prop, enums, defs) {
			continue
		}

		target := ent.Relationships[name].Target
		fks = append(fks, fmt.Sprintf("FOREIGN KEY (%s) REFERENCES %s(id)", name, pluralize(toSnake(target))))
	}

	return fks
}

func isArrayProperty(prop definitionSpec, enums map[string]enumSpec, defs map[string]definitionSpec) bool {
	resolved, err := resolveProperty(prop, enums, defs)
	if err != nil {
		return false
	}
	return resolved.Type == typeArray
}

func sqlTypeForProperty(prop definitionSpec, enums map[string]enumSpec, defs map[string]definitionSpec, dialect dialectSpec) (string, error) {
	resolved, err := resolveProperty(prop, enums, defs)
	if err != nil {
		return "", err
	}

	switch resolved.Type {
	case typeString:
		switch strings.ToLower(resolved.Format) {
		case "uuid", "uuidv7", "uuidv4":
			return dialect.uuidType, nil
		case dateTimeFormat:
			return dialect.dateTimeType, nil
		default:
			return dialect.stringType, nil
		}
	case typeInteger:
		return dialect.integerType, nil
	case typeNumber:
		return dialect.numberType, nil
	case typeBoolean:
		return dialect.booleanType, nil
	case typeArray, typeObject:
		return dialect.jsonType, nil
	default:
		if len(resolved.Properties) > 0 {
			return dialect.jsonType, nil
		}
	}

	return dialect.jsonType, nil
}

func resolveProperty(prop definitionSpec, enums map[string]enumSpec, defs map[string]definitionSpec) (definitionSpec, error) {
	if prop.Ref == "" {
		return prop, nil
	}
	if def := resolveRef(prop.Ref, enums, defs); def != nil {
		return *def, nil
	}
	return prop, fmt.Errorf("unsupported ref %q", prop.Ref)
}

func hasIDColumn(cols []columnSpec) bool {
	for _, col := range cols {
		if col.name == "id" {
			return true
		}
	}
	return false
}

func resolveRef(ref string, enums map[string]enumSpec, defs map[string]definitionSpec) *definitionSpec {
	const enumPrefix = "#/enums/"
	const defPrefix = "#/definitions/"

	switch {
	case strings.HasPrefix(ref, enumPrefix):
		if _, ok := enums[strings.TrimPrefix(ref, enumPrefix)]; ok {
			return &definitionSpec{Type: typeString}
		}
	case strings.HasPrefix(ref, defPrefix):
		if def, ok := defs[strings.TrimPrefix(ref, defPrefix)]; ok {
			return &def
		}
	}
	return nil
}

func toSnake(s string) string {
	runes := []rune(s)
	if len(runes) == 0 {
		return ""
	}

	var out []rune
	appendUnderscore := func() {
		if len(out) == 0 || out[len(out)-1] != '_' {
			out = append(out, '_')
		}
	}
	for i, r := range runes {
		if r == '-' || r == ' ' || r == '.' {
			appendUnderscore()
			continue
		}
		if isUpperASCII(r) {
			if i > 0 {
				prev := runes[i-1]
				if isLowerASCII(prev) || (i+1 < len(runes) && isLowerASCII(runes[i+1])) {
					appendUnderscore()
				}
			}
			out = append(out, toLowerASCII(r))
			continue
		}
		out = append(out, r)
	}
	return string(out)
}

func isUpperASCII(r rune) bool {
	return r >= 'A' && r <= 'Z'
}

func isLowerASCII(r rune) bool {
	return r >= 'a' && r <= 'z'
}

func toLowerASCII(r rune) rune {
	if isUpperASCII(r) {
		return r + ('a' - 'A')
	}
	return r
}

func pluralize(s string) string {
	if strings.HasSuffix(s, "s") {
		return s
	}
	if strings.HasSuffix(s, "y") && len(s) > 1 {
		prev := s[len(s)-2]
		switch prev {
		case 'a', 'e', 'i', 'o', 'u':
		default:
			return s[:len(s)-1] + "ies"
		}
	}
	return s + "s"
}
